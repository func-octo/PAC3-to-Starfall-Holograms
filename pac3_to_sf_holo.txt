--@name PAC3 to Holo v1.3.0
--@author Octo
--@shared

--[[
    DOCUMENTATION

    TO USE: Include this file within another file and save it to a variable. This is how you will call all functions.
            See example file for an applied use of this library.

    SHARED:
        buildHologramsFromTable(Table PAC file table, Entity parent, Function callback)
        - This generates holograms from an already loaded PAC file as a table
        - The callback function has one argument that returns a table of all the hologram entities that were created
    
    CLIENT:
        loadPACToTable(String PAC filename)
        - This takes a PAC3 save file and turns it into a Lua table to be iterated through or modified
        
        buildHologramsFromFile(String PAC filename, Entity parent, Function callback)
        - This generates holograms given a filepath to a PAC3 save file.
        - The callback function has one argument that returns a table of all the hologram entities that were created
]]

pacHolo = {}

-- Some functions for checking our quota usage.
local function checkQ(n)
    return quotaAverage() < quotaMax()*n
end

-- Check if we should yield
local function yieldCheck()
    if not checkQ(0.95) then
        coroutine.yield()
    end
end

--Strip bone name to match PAC format and see if any match ours.
local boneNameReplacements =
{
    {"Anim_Attachment", "attach"},
    {"RH", "right hand"},
    {"LH", "left hand"},
    {"_L_", " left "},
    {"_R_", " right "},
    {"%p", " "},
    {"ValveBiped", ""},
    {"Bip01", ""},
    {"Neck1", "neck"},
    {"Head1", "head"},
    {"Toe0", "toe"},
    {"lowerarm", "lower arm"},
    {"Bip", ""},
    {" R", " right"},
    {" L", " left"}
}
local function getBoneNameFromPAC( targetEnt, boneName )
    local targetBoneCount = targetEnt:getBoneCount()
    for i = 0, targetBoneCount - 1 do
        local name = targetEnt:getBoneName( i )
        local friendly = name
        
        if name then
            for _, entry in pairs( boneNameReplacements ) do
                friendly = string.gsub( friendly, entry[1], entry[2] )
            end
            
            friendly = string.gsub( string.lower( string.trim( friendly ) ), "(.-)(%d+)", "%1 %2" )
            
            if friendly == boneName then
                return name
            end
        end
    end
    return ""
end

local function buildHologramsFromTable(tbl, parent, parentPart)
    parent = parent or chip()
    local holos = {}
    local bodygroups = {}
    local submats = {}
    local clips = {}
    local bones = {}
    
    for index, part in pairs(tbl) do
        local className = part["self"].ClassName
        
        if className == "model2" or className == "model" then
            if not hologram.canSpawn() then
                coroutine.yield()
            end
            --Build a new hologram with the found info.
            local partInfo = part["self"]
            local boneParent = parent:lookupBone( getBoneNameFromPAC( parent, partInfo.Bone ) )
            local newHolo = hologram.create(parent:localToWorld(partInfo.Position), parent:localToWorldAngles(partInfo.Angles + partInfo.AngleOffset), partInfo.Model, partInfo.Scale * partInfo.Size)
            
            if boneParent then
                local bp, ba = parent:getBonePosition( boneParent )
                local hp, ha = localToWorld( partInfo.Position + partInfo.PositionOffset, partInfo.Angles + partInfo.AngleOffset, bp, ba )
                newHolo:setPos( hp )
                newHolo:setAngles( ha )
                newHolo:setParent(parent, nil, boneParent)
            else
                newHolo:setParent(parent, nil, boneParent)
                newHolo:setPos(newHolo:localToWorld(partInfo.PositionOffset))
            end
            
            if className == "model2" then
                newHolo:setColor(Color(partInfo.Color[1] * 255, partInfo.Color[2] * 255, partInfo.Color[3] * 255, partInfo.Alpha * 255))
            else
                newHolo:setColor(Color(partInfo.Color[1], partInfo.Color[2], partInfo.Color[3], partInfo.Alpha * 255))
            end
            
            newHolo:setMaterial(partInfo.Material)
            newHolo:setSkin(partInfo.Skin)
            newHolo:suppressEngineLighting(partInfo.NoLighting or partInfo.Fullbright or false)
            newHolo.Name = partInfo.Name
            newHolo.Notes = partInfo.Notes
            newHolo.UID = partInfo.UniqueID
            newHolo.clipCount = 0
            table.insert(holos, newHolo)
            
            --Check for children to recurse into.
            if #part.children > 0 then
                yieldCheck()
                local children, bodygroups, submats, clipsList, boneList = buildHologramsFromTable(part.children, newHolo, part)
                table.add(holos, children)
                table.add(clips, clipsList)
                table.add(bones, boneList)
                yieldCheck()
                
                --Apply bodygroups
                for index, bodygroup in pairs(bodygroups) do
                    newHolo:setBodygroup(newHolo:lookupBodygroup(bodygroup.BodyGroupName), bodygroup.ModelIndex)
                    yieldCheck()
                end
                
                --Apply submaterials
                for index, submat in pairs(submats) do
                    newHolo:setSubMaterial(submat.SubMaterialId - 1, submat.Material)
                    yieldCheck()
                end
            end
        elseif className == "bodygroup" then
            table.insert(bodygroups, {
                BodyGroupName = part["self"].BodyGroupName,
                ModelIndex = part["self"].ModelIndex
            })
        elseif className == "submaterial" then
            table.insert(submats, {
                SubMaterialId = part["self"].SubMaterialId,
                Material = part["self"].Material
            })
        elseif className == "clip2" or className == "clip" then
            local target = part["self"].TargetEntityUID
            if target == "" then
                target = parentPart["self"].UniqueID
            end
            table.insert(clips, {
                Parent = parent,
                TargetEntityUID = target,
                Position = part["self"].Position,
                PositionOffset = part["self"].PositionOffset,
                Angles = part["self"].Angles,
                AngleOffset = part["self"].AngleOffset
            })
        elseif className == "bone" or className == "bone3" then
            local target = part["self"].TargetEntityUID
            if target == "" then
                target = parentPart["self"].UniqueID
            end
            table.insert(bones, {
                Parent = parent,
                TargetEntityUID = target,
                Jiggle = part["self"].Jiggle,
                Position = part["self"].Position,
                PositionOffset = part["self"].PositionOffset,
                Angles = part["self"].Angles,
                AngleOffset = part["self"].AngleOffset,
                Scale = part["self"].Scale,
                Bone = part["self"].Bone
            })
        else --Covers groups and other intangible elements that may house valid components
            --Check for children to recurse into.
            if #part.children > 0 then
                yieldCheck()
                local children, bodygroups, submats, clipsList, boneList = buildHologramsFromTable(part.children, parent, part)
                table.add(holos, children)
                table.add(clips, clipsList)
                table.add(bones, boneList)
                yieldCheck()
            end
        end
        
        yieldCheck()
    end
    
    return holos, bodygroups, submats, clips, bones
end


--Need to apply clips after we know all of the holograms.
local function buildHolosFromTableApplyClips(tbl, parent)
    local holos, bodygroups, submats, clips, bones = buildHologramsFromTable(tbl, parent)
    
    --Apply clips
    for index, clip in pairs(clips) do
        local clipPos, clipAng = worldToLocal(clip.PositionOffset, clip.AngleOffset, clip.Position, clip.Angles)
        local targetEnt
        
        for index, holo in pairs(holos) do
            if holo.UID == clip.TargetEntityUID then
                targetEnt = holo
                break
            end
        end
        
        targetEnt:setClip(clip.Parent.clipCount + 1, true, clip.Position, -clipAng:getForward(), targetEnt)
        targetEnt.clipCount = clip.Parent.clipCount + 1
        yieldCheck()
    end
    
    --Apply bone manip
    for index, bone in pairs( bones ) do
        local targetEnt
        
        for index, holo in pairs(holos) do
            if holo.UID == bone.TargetEntityUID then
                targetEnt = holo
                break
            end
        end
        
        
        local realBoneName = getBoneNameFromPAC( targetEnt, bone.Bone )
        local boneIndex = targetEnt:lookupBone( realBoneName )
        if boneIndex then
            targetEnt:manipulateBonePosition( boneIndex, bone.Position + bone.PositionOffset )
            targetEnt:manipulateBoneAngles( boneIndex, bone.Angles + bone.AngleOffset )
            targetEnt:manipulateBoneScale( boneIndex, bone.Scale or Vector( 1, 1, 1 ) )
            targetEnt:manipulateBoneJiggle( boneIndex, bone.Jiggle or false )
        else
            print( "Did not find any bone named '" .. bone.Bone .. "' in model '" .. string.getFileFromFilename( targetEnt:getModel() ) .. "'" )
        end
        
        yieldCheck()
    end
    
    return holos, bodygroups, submats, clips, bones
end

if CLIENT then
    --Convert a PAC to a table of holograms using a path relative to the PAC3 folder.
    --This will ONLY convert MODEL parts.
    pacHolo.loadPACToTable = function(path)
        local pacString = file.readInGame("/data/pac3/" .. path .. ".txt")

        -- we create a new env so then any global variables don't edit our old env
        local env = { Vector = Vector, Angle = Angle, Color = Color }
        local func, err = loadstring( "return { " .. pacString .. "}", "decodedPac", env )
        
        if err then
            return false, err
        end
        return func(), nil
    end
    
    --Create holograms from the PAC file and parent it to the given entity.
    pacHolo.buildHologramsFromFile = function(path, rootParent, callback)
        rootParent = rootParent or chip()
        local pacTable, error = pacHolo.loadPACToTable(path)
        
        --If we failed to load the pac, let us know why.
        if not pacTable and error then
            throw(error)
        end
        
        --Build holograms from table using a pausable coroutine.
        local holoBuilder = coroutine.create(buildHolosFromTableApplyClips)
        hook.add("think", "buildHolosCoroutine", function()
            -- If the coroutine hasn't died, then we need to start it or resume it.
            if coroutine.status(holoBuilder) ~= "dead" then
                -- Make sure we're sufficiently below quota to resume
                if checkQ(0.8) then
                    -- r will be nil until the final yield which gives us our primes.
                    -- This will start / resume the coroutine.
                    local holoTable = coroutine.resume(holoBuilder, pacTable, rootParent)
        
                    -- Therefore we check if it's not nil, and print the highest prime.
                    if holoTable then
                        callback(holoTable)
                        hook.remove("think", "buildHolosCoroutine")
                    end
                end
            end
        end)
    end
end

--Create holograms from the given PAC table and parent it to the given entity.
pacHolo.buildHologramsFromTable = function(pacTable, rootParent, callback)
    rootParent = rootParent or chip()
    
    --Build holograms from table using a pausable coroutine.
    local holoBuilder = coroutine.create(buildHolosFromTableApplyClips)
    hook.add("think", "buildHolosCoroutine", function()
        -- If the coroutine hasn't died, then we need to start it or resume it.
        if coroutine.status(holoBuilder) ~= "dead" then
            -- Make sure we're sufficiently below quota to resume
            if checkQ(0.8) then
                -- r will be nil until the final yield which gives us our primes.
                -- This will start / resume the coroutine.
                local holoTable = coroutine.resume(holoBuilder, pacTable, rootParent)
    
                -- Therefore we check if it's not nil, and print the highest prime.
                if holoTable then
                    callback(holoTable)
                    hook.remove("think", "buildHolosCoroutine")
                end
            end
        end
    end)
end

return pacHolo
